//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';


export type SumGETQueryParameters = {
  num1: number ;
  num2: number ;
}

export type SumGET2QueryParameters = {
  num1: number ;
  num2: number ;
}

export type SumGET3QueryParameters = {
  num1: number ;
  num2: number ;
}

export function loginUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/auth/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * Handle login and set the access token into the cookie
 * @param body Body
 * @return OK
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<Types.ResponseBool, unknown, Types.LoginInput, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ResponseBool, unknown, Types.LoginInput, TContext> {
  const key = loginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LoginInput) => Client().login(body),
    mutationKey: key,
  });
}
  
export function logoutUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/auth/logout";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let logoutDefaultOptions: Omit<UseQueryOptions<Types.ResponseBool, unknown, Types.ResponseBool>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseBool, unknown, Types.ResponseBool>, 'queryFn'>> = {
};
export function getLogoutDefaultOptions() {
  return logoutDefaultOptions;
};
export function setLogoutDefaultOptions(options: typeof logoutDefaultOptions) {
  logoutDefaultOptions = options;
}

export function logoutQueryKey(): QueryKey;
export function logoutQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'logout',
    ]);
}
export function __logout(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().logout(
);
}

/**
 * Handle logout and clear the access token from the Cookie
 * @return OK
 */
export function useLogoutQuery<TSelectData = Types.ResponseBool, TError = unknown>(options?: Omit<UseQueryOptions<Types.ResponseBool, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLogoutQuery<TSelectData = Types.ResponseBool, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseBool, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseBool, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __logout(context, axiosConfig) : __logout,
    queryKey: logoutQueryKey(),
    ...logoutDefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseBool, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Handle logout and clear the access token from the Cookie
 * @return OK
 */
export function setLogoutData(queryClient: QueryClient, updater: (data: Types.ResponseBool | undefined) => Types.ResponseBool, ) {
  queryClient.setQueryData(logoutQueryKey(),
    updater
  );
}

/**
 * Handle logout and clear the access token from the Cookie
 * @return OK
 */
export function setLogoutDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseBool | undefined) => Types.ResponseBool) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function catsUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/facts/cats";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let catsDefaultOptions: Omit<UseQueryOptions<Types.ResponseArray_handler_FactResponse, unknown, Types.ResponseArray_handler_FactResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseArray_handler_FactResponse, unknown, Types.ResponseArray_handler_FactResponse>, 'queryFn'>> = {
};
export function getCatsDefaultOptions() {
  return catsDefaultOptions;
};
export function setCatsDefaultOptions(options: typeof catsDefaultOptions) {
  catsDefaultOptions = options;
}

export function catsQueryKey(): QueryKey;
export function catsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'cats',
    ]);
}
export function __cats(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().cats(
);
}

/**
 * Facts about cats
 * @return OK
 */
export function useCatsQuery<TSelectData = Types.ResponseArray_handler_FactResponse, TError = unknown>(options?: Omit<UseQueryOptions<Types.ResponseArray_handler_FactResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCatsQuery<TSelectData = Types.ResponseArray_handler_FactResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseArray_handler_FactResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseArray_handler_FactResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __cats(context, axiosConfig) : __cats,
    queryKey: catsQueryKey(),
    ...catsDefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseArray_handler_FactResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Facts about cats
 * @return OK
 */
export function setCatsData(queryClient: QueryClient, updater: (data: Types.ResponseArray_handler_FactResponse | undefined) => Types.ResponseArray_handler_FactResponse, ) {
  queryClient.setQueryData(catsQueryKey(),
    updater
  );
}

/**
 * Facts about cats
 * @return OK
 */
export function setCatsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseArray_handler_FactResponse | undefined) => Types.ResponseArray_handler_FactResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dogsUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/facts/dogs";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dogsDefaultOptions: Omit<UseQueryOptions<Types.ResponseHandler_FactResponse, unknown, Types.ResponseHandler_FactResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseHandler_FactResponse, unknown, Types.ResponseHandler_FactResponse>, 'queryFn'>> = {
};
export function getDogsDefaultOptions() {
  return dogsDefaultOptions;
};
export function setDogsDefaultOptions(options: typeof dogsDefaultOptions) {
  dogsDefaultOptions = options;
}

export function dogsQueryKey(): QueryKey;
export function dogsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'dogs',
    ]);
}
export function __dogs(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().dogs(
);
}

/**
 * Facts about dogs
 * @return OK
 */
export function useDogsQuery<TSelectData = Types.ResponseHandler_FactResponse, TError = unknown>(options?: Omit<UseQueryOptions<Types.ResponseHandler_FactResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDogsQuery<TSelectData = Types.ResponseHandler_FactResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseHandler_FactResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseHandler_FactResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dogs(context, axiosConfig) : __dogs,
    queryKey: dogsQueryKey(),
    ...dogsDefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseHandler_FactResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Facts about dogs
 * @return OK
 */
export function setDogsData(queryClient: QueryClient, updater: (data: Types.ResponseHandler_FactResponse | undefined) => Types.ResponseHandler_FactResponse, ) {
  queryClient.setQueryData(dogsQueryKey(),
    updater
  );
}

/**
 * Facts about dogs
 * @return OK
 */
export function setDogsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseHandler_FactResponse | undefined) => Types.ResponseHandler_FactResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function sumGETUrl(num1: number, num2: number): string {
  let url_ = getBaseUrl() + "/api/v1/sum?";
  if (num1 === undefined || num1 === null)
    throw new Error("The parameter 'num1' must be defined and cannot be null.");
  else
    url_ += "num1=" + encodeURIComponent("" + num1) + "&";
  if (num2 === undefined || num2 === null)
    throw new Error("The parameter 'num2' must be defined and cannot be null.");
  else
    url_ += "num2=" + encodeURIComponent("" + num2) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sumGETDefaultOptions: Omit<UseQueryOptions<Types.ResponseSumOutput, unknown, Types.ResponseSumOutput>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseSumOutput, unknown, Types.ResponseSumOutput>, 'queryFn'>> = {
};
export function getSumGETDefaultOptions() {
  return sumGETDefaultOptions;
};
export function setSumGETDefaultOptions(options: typeof sumGETDefaultOptions) {
  sumGETDefaultOptions = options;
}

export function sumGETQueryKey(dto: SumGETQueryParameters): QueryKey;
export function sumGETQueryKey(num1: number, num2: number): QueryKey;
export function sumGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { num1, num2,  } = params[0] as SumGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'sumGET',
        num1 as any,
        num2 as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'sumGET',
        ...params
      ]);
  }
}
export function __sumGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().sumGET(
      context.queryKey[2] as number,       context.queryKey[3] as number);
}

export function useSumGETQuery<TSelectData = Types.ResponseSumOutput, TError = unknown>(dto: SumGETQueryParameters, options?: Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Handle the sum service using the query string
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function useSumGETQuery<TSelectData = Types.ResponseSumOutput, TError = unknown>(num1: number, num2: number, options?: Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSumGETQuery<TSelectData = Types.ResponseSumOutput, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let num1: any = undefined;
  let num2: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ num1, num2,  } = params[0] as SumGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [num1, num2, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseSumOutput, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __sumGET(context, axiosConfig) : __sumGET,
    queryKey: sumGETQueryKey(num1, num2),
    ...sumGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Handle the sum service using the query string
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function setSumGETData(queryClient: QueryClient, updater: (data: Types.ResponseSumOutput | undefined) => Types.ResponseSumOutput, num1: number, num2: number) {
  queryClient.setQueryData(sumGETQueryKey(num1, num2),
    updater
  );
}

/**
 * Handle the sum service using the query string
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function setSumGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseSumOutput | undefined) => Types.ResponseSumOutput) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function sumPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/sum";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sumPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'sumPOST',
    ]);
}

/**
 * Handle the sum service using the body
 * @param input body input
 * @return OK
 */
export function useSumPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ResponseSumOutput, unknown, Types.SumInput, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ResponseSumOutput, unknown, Types.SumInput, TContext> {
  const key = sumPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (input: Types.SumInput) => Client().sumPOST(input),
    mutationKey: key,
  });
}
  
export function sumGET2Url(num1: number, num2: number): string {
  let url_ = getBaseUrl() + "/api/v1/sum/{num1}?";
if (num1 === undefined || num1 === null)
  throw new Error("The parameter 'num1' must be defined.");
url_ = url_.replace("{num1}", encodeURIComponent("" + num1));
  if (num2 === undefined || num2 === null)
    throw new Error("The parameter 'num2' must be defined and cannot be null.");
  else
    url_ += "num2=" + encodeURIComponent("" + num2) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sumGET2DefaultOptions: Omit<UseQueryOptions<Types.ResponseSumOutput, unknown, Types.ResponseSumOutput>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseSumOutput, unknown, Types.ResponseSumOutput>, 'queryFn'>> = {
};
export function getSumGET2DefaultOptions() {
  return sumGET2DefaultOptions;
};
export function setSumGET2DefaultOptions(options: typeof sumGET2DefaultOptions) {
  sumGET2DefaultOptions = options;
}

export function sumGET2QueryKey(dto: SumGET2QueryParameters): QueryKey;
export function sumGET2QueryKey(num1: number, num2: number): QueryKey;
export function sumGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { num1, num2,  } = params[0] as SumGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'sumGET2',
        num1 as any,
        num2 as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'sumGET2',
        ...params
      ]);
  }
}
export function __sumGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().sumGET2(
      context.queryKey[2] as number,       context.queryKey[3] as number);
}

export function useSumGET2Query<TSelectData = Types.ResponseSumOutput, TError = unknown>(dto: SumGET2QueryParameters, options?: Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Handle sum with first number in route path and second in query string
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function useSumGET2Query<TSelectData = Types.ResponseSumOutput, TError = unknown>(num1: number, num2: number, options?: Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSumGET2Query<TSelectData = Types.ResponseSumOutput, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let num1: any = undefined;
  let num2: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ num1, num2,  } = params[0] as SumGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [num1, num2, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseSumOutput, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __sumGET2(context, axiosConfig) : __sumGET2,
    queryKey: sumGET2QueryKey(num1, num2),
    ...sumGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Handle sum with first number in route path and second in query string
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function setSumGET2Data(queryClient: QueryClient, updater: (data: Types.ResponseSumOutput | undefined) => Types.ResponseSumOutput, num1: number, num2: number) {
  queryClient.setQueryData(sumGET2QueryKey(num1, num2),
    updater
  );
}

/**
 * Handle sum with first number in route path and second in query string
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function setSumGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseSumOutput | undefined) => Types.ResponseSumOutput) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function sumGET3Url(num1: number, num2: number): string {
  let url_ = getBaseUrl() + "/api/v1/sum/{num1}/{num2}";
if (num1 === undefined || num1 === null)
  throw new Error("The parameter 'num1' must be defined.");
url_ = url_.replace("{num1}", encodeURIComponent("" + num1));
if (num2 === undefined || num2 === null)
  throw new Error("The parameter 'num2' must be defined.");
url_ = url_.replace("{num2}", encodeURIComponent("" + num2));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sumGET3DefaultOptions: Omit<UseQueryOptions<Types.ResponseSumOutput, unknown, Types.ResponseSumOutput>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseSumOutput, unknown, Types.ResponseSumOutput>, 'queryFn'>> = {
};
export function getSumGET3DefaultOptions() {
  return sumGET3DefaultOptions;
};
export function setSumGET3DefaultOptions(options: typeof sumGET3DefaultOptions) {
  sumGET3DefaultOptions = options;
}

export function sumGET3QueryKey(dto: SumGET3QueryParameters): QueryKey;
export function sumGET3QueryKey(num1: number, num2: number): QueryKey;
export function sumGET3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { num1, num2,  } = params[0] as SumGET3QueryParameters;

    return trimArrayEnd([
        'Client',
        'sumGET3',
        num1 as any,
        num2 as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'sumGET3',
        ...params
      ]);
  }
}
export function __sumGET3(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().sumGET3(
      context.queryKey[2] as number,       context.queryKey[3] as number);
}

export function useSumGET3Query<TSelectData = Types.ResponseSumOutput, TError = unknown>(dto: SumGET3QueryParameters, options?: Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Handle the sum service using the route path
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function useSumGET3Query<TSelectData = Types.ResponseSumOutput, TError = unknown>(num1: number, num2: number, options?: Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSumGET3Query<TSelectData = Types.ResponseSumOutput, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let num1: any = undefined;
  let num2: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ num1, num2,  } = params[0] as SumGET3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [num1, num2, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseSumOutput, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __sumGET3(context, axiosConfig) : __sumGET3,
    queryKey: sumGET3QueryKey(num1, num2),
    ...sumGET3DefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseSumOutput, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Handle the sum service using the route path
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function setSumGET3Data(queryClient: QueryClient, updater: (data: Types.ResponseSumOutput | undefined) => Types.ResponseSumOutput, num1: number, num2: number) {
  queryClient.setQueryData(sumGET3QueryKey(num1, num2),
    updater
  );
}

/**
 * Handle the sum service using the route path
 * @param num1 Number One
 * @param num2 Number Two
 * @return OK
 */
export function setSumGET3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseSumOutput | undefined) => Types.ResponseSumOutput) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function heartbeatUrl(): string {
  let url_ = getBaseUrl() + "/heartbeat";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let heartbeatDefaultOptions: Omit<UseQueryOptions<Types.ResponseString, unknown, Types.ResponseString>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ResponseString, unknown, Types.ResponseString>, 'queryFn'>> = {
};
export function getHeartbeatDefaultOptions() {
  return heartbeatDefaultOptions;
};
export function setHeartbeatDefaultOptions(options: typeof heartbeatDefaultOptions) {
  heartbeatDefaultOptions = options;
}

export function heartbeatQueryKey(): QueryKey;
export function heartbeatQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'heartbeat',
    ]);
}
export function __heartbeat(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().heartbeat(
);
}

/**
 * Heartbeat returns a JSON response with the heartbeat status
 * @return OK
 */
export function useHeartbeatQuery<TSelectData = Types.ResponseString, TError = unknown>(options?: Omit<UseQueryOptions<Types.ResponseString, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHeartbeatQuery<TSelectData = Types.ResponseString, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ResponseString, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ResponseString, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __heartbeat(context, axiosConfig) : __heartbeat,
    queryKey: heartbeatQueryKey(),
    ...heartbeatDefaultOptions as unknown as Omit<UseQueryOptions<Types.ResponseString, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Heartbeat returns a JSON response with the heartbeat status
 * @return OK
 */
export function setHeartbeatData(queryClient: QueryClient, updater: (data: Types.ResponseString | undefined) => Types.ResponseString, ) {
  queryClient.setQueryData(heartbeatQueryKey(),
    updater
  );
}

/**
 * Heartbeat returns a JSON response with the heartbeat status
 * @return OK
 */
export function setHeartbeatDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ResponseString | undefined) => Types.ResponseString) {
  queryClient.setQueryData(queryKey, updater);
}